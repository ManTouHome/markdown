# 集合

## 一丶Collection接口

### 1.Collection接口常用方法

```java
package com.mantou.collection;

import java.util.ArrayList;
import java.util.Collection;

/**
 * @author mantou
 * @date 2021/11/1 13:52
 * @return
 * @desc collection接口
 *       集合的特点，集合只能存储引用数据类型数据，基本数据类型会自动装箱存储。
 */
public class CollectionTest {
    public static void main(String[] args) {
        Collection collection = new ArrayList();
        Collection collection1 = new ArrayList();
        //1.增加功能   add(E e)   addAll(Collection<? extends E> c)
        collection.add(15);
        collection.add(12);
        collection.add(6);
        collection.add("mantou");
        System.out.println(collection.toString());    //[15, 12, 6, mantou]

        collection1.add(6);
        collection1.add("mantou");

        collection.addAll(collection1);

        System.out.println(collection.toString());  // [15, 12, 6, mantou, 6, mantou]

        //2.判断功能   contains(Object o)  equals(Object o)  isEmpty()
        System.out.println(collection.contains("mantou"));   //true
        System.out.println(collection.containsAll(collection1));  //true
        System.out.println(collection.equals(collection1)); //false
        System.out.println(collection.isEmpty());  //false
        //3.查看功能   size()
        System.out.println(collection.size());    //   6
        //4.转换功能   toArray()
        System.out.println(collection.toArray()[0]);  //  15
        //5.删除功能   clear()   remove(Object o)
        System.out.println(collection.remove("mantou"));  //true
        collection.clear();
        System.out.println(collection.size()); //   0
    }
}

```

### 2.遍历collection

```java
package com.mantou.collection;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * @author mantou
 * @date 2021/11/1 14:15
 * @return
 * @desc 遍历collection集合
 */
public class CollectionTest02 {
    public static void main(String[] args) {
        Collection collection = new ArrayList();
        collection.add("zhangsan");
        collection.add("lisi");
        collection.add("wangwu");
        collection.add("zhaoliu");
        //方式1：普通for循环   , 没有获取元素的方法，所以不能使用普通for循环

        //方式2：增强for循环
        for (Object c: collection) {
            System.out.println(c);
        }
        //方式3：迭代器
        Iterator iterator = collection.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

### 3.实现类

<img src="../../img/collections/collectionimpl.png"  />

## 二丶List接口

### 1.List接口常用方法

```java
package com.mantou.list;

import java.util.ArrayList;
import java.util.List;

/**
 * @author mantou
 * @date 2021/11/1 14:34
 * @return
 * @desc List接口常用方法
 */
public class ListTest01 {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(3);
        list.add(5);
        list.add("mantou");
        //1.增加功能  add(int index, E element)
        list.add(2,"lisi");
        //2.查看功能  get(int index)
        System.out.println(list.get(2));   //lisi
        //3.修改功能
        System.out.println(list.set(2, "wangwu"));  // lisi
        //4.删除功能  remove(int index)
        System.out.println(list.remove(2));  //wangwu
    }
}
```

### 2.遍历List

```java
//1.普通for循环
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}
//2.增强for循环
for (Object o : list) {
    System.out.println(o);
}
//3.迭代器
Iterator iterator = list.iterator();
while (iterator.hasNext()){
    System.out.println(iterator.next());
}
```

## 三丶ArrayList集合

### 1.ArrayList源码区别

```
* JDK1.7是创建时初始化长度为10，之后每次扩容为之前的1.5倍
* JDK1.8是调用add方法的时候才会初始化长度为10
```

### 2.ArrayList与Vector的区别

```
*  arraylist扩容为实际数组长度的1.5倍  线程不安全  效率高
*  vector 扩容为实际数组长度的2倍   线程安全   效率低 （已经淘汰）
```

## 四丶LinkedList集合

### 1.LinkedList的常用API和遍历

```java
package com.mantou.list;

import java.util.Iterator;
import java.util.LinkedList;

/**
 * @author mantou
 * @date 2021/11/2 14:20
 * @desc LinkedList 常用API
 * 注意：尽量使用JDK1.6之后更新的增删改查接口，因为增强了健壮性，例如空链表使用remove方法会报错，但是使用poll不会
 * 总结：增加使用offer 查看使用peek 删除使用poll
 */
public class LinkedListTest {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        //1.增加 add(E e) add(int index, E element) addFirst(E e) addLast(E e)  JDK1.6之前的接口
        // offer(E e)  offerFirst(E e)  offerLast(E e)  JDK1.6 的接口
        list.add("zhangsan");   //添加到列表的末尾
        list.offer("mantou");   //添加到列表的末尾
        list.offerFirst("lisi");    //添加到列表前面
        list.offerLast("wangwu");   //添加到列表末尾
        System.out.println(list.toString());   // [lisi, zhangsan, mantou, wangwu]
        //2.修改  set(int index, E element)
        list.set(1,"zhaoliu");
        //3.查看  get(int index) getFirst() getLast() size()
        System.out.println(list.get(1));
        System.out.println(list.getFirst());
        System.out.println(list.getLast());
        //peek() peekFirst() peekLast()
        System.out.println(list.peek());  //查找链表第一个元素
        System.out.println(list.peekFirst()); //查找链表第一个元素
        System.out.println(list.peekLast()); //查找链表最后一个元素
        //4.删除 clear()  remove(int index) removeFirst() removeLast()
        //poll() pollFirst() pollLast()
        //list.clear();   //清空链表
        //System.out.println(list.poll());  //删除链表第一个元素 ，空链表不会报错 ，返回null
        //System.out.println(list.remove()); //删除链表第一个元素, 空链表报错
        //5.判断  contains(Object o)
        System.out.println("_________________________________________");
        //遍历
        //方式1：普通for
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
        System.out.println("_________________________________________");
        //方式2：增强for
        for(String s : list) {
            System.out.println(s);
        }
        System.out.println("_________________________________________");
        //方式3：迭代器
        Iterator<String> it = list.iterator();
        while (it.hasNext()){
            System.out.println(it.next());
        }
        System.out.println("_________________________________________");
        //方式4：for循环迭代  ，这种方式更好，因为节省内存
        for (Iterator<String> it2 = list.iterator();it2.hasNext();){
            System.out.println(it2.next());
        }

    }
}
```

### 2.LinkedList底层原理

底层：使用的是双向链表

![](../../img/JavaSE/collections/linkedList01.png)

### 3.仿写LinkedList源码

Node类

```java
package com.mantou.entity;
/**
 * @author mantou
 * @date 2021/11/2 16:42
 * @desc 节点类
 */
public class Node<E> {
    /**
     * 前一个元素
     */
    private Node<E> pre ;
    /**
     * 存储的数据
     */
    private E data ;
    /**
     * 后一个元素
     */
    private Node<E> next ;

    public Node() {
    }

    public Node<E> getPre() {
        return pre;
    }

    public void setPre(Node<E> pre) {
        this.pre = pre;
    }

    public E getData() {
        return data;
    }

    public void setData(E data) {
        this.data = data;
    }

    public Node<E> getNext() {
        return next;
    }

    public void setNext(Node<E> next) {
        this.next = next;
    }

    @Override
    public String toString() {
        return "Node{" +
                "pre=" + pre +
                ", data=" + data +
                ", next=" + next +
                '}';
    }
}
```

MyLinkedList类

```java
package com.mantou.list;

import com.mantou.entity.Node;

import java.util.ArrayList;

/**
 * @author mantou
 * @date 2021/11/2 16:46
 * @desc 仿写LinkedList源码
 */
public class MyLinkedList<E> {
    /**
     * 首节点
     */
    private Node<E> first ;

    /**
     * 尾节点
     */
    private Node<E> last ;

    /**
     * 计数器
     */
    private Integer count = 0;

    /**
     * 空参构造器
     */
    public MyLinkedList() {
    }

    /**
     * add方法
     */
    public void add(E data){
        if (first == null) {    //表示这是第一个元素
            Node<E> node = new Node();
            node.setPre(null);
            node.setData(data);
            node.setNext(null);
            //当前链中第一个节点变为node
            first = node ;
            //当前最后一个节点变为node
            last = node ;
        }else{     //表示不是第一个节点了
            Node<E> node = new Node();
            node.setPre(last);
            node.setData(data);
            node.setNext(null);
            //当前链中的最后一个节点的下一个元素指向node
            last.setNext(node);
            //将最后一个节点变为n
            last = node ;
        }
        //链中元素数量增加
        count++ ;
    }

    /**
     * 获取集合中的元素数量
     */
    public Integer getSize(){
        return count ;
    }
    /**
     * 通过index获取集合中的元素
     */
    public E get(Integer index){
        //获取链表头元素
        Node<E> node = first ;
        for (int i = 0; i < index; i++) {
            node = node.getNext() ;
        }
        return (E) node.getData();
    }

}
class TestMyList{
    public static void main(String[] args) {
        MyLinkedList<String> list = new MyLinkedList<>();
        list.add("mantou");
        list.add("zhangsan");
        list.add("wangwu");
        for (int i = 0; i < list.getSize() ; i++) {
            System.out.println(list.get(i));
        }
        System.out.println(list.getSize());
    }
}
```

## 五丶Iterator

### 1.Iterator关系图

![](../../img/collections/iterator.png)

## 六丶Set集合

### 1.Hashset的特点

hashset ： 无序，唯一 ，存储自定义类型必须重写hashcode和equals方法

​					数组 + 链表

### 2.HashSet的原理图

![](../../img/collections/hashset.png)

### 3.LinkedHashSet特点

LinkedHashSet：唯一，有序（按照插入顺序就行输出）

### 4.LinkedHashSet原理

![](../../img/collections/linkedhashset.png)

### 5.TreeSet特点

TreeSet：唯一，无序（没有按照插入顺序排序），有序（按照升序排序） 使用中序遍历

​		存储自定义类型必须重写Compare比较器方法

### 6.TreeSet原理

![](../../img/collections/treeset.png)

### 7.TreeSet示例

```java
package com.mantou.entity;

public class Person implements Comparable<Person>{
    private String name ;
    private Integer age ;

    public Person() {
    }

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    //内部比较器
    @Override
    public int compareTo(Person o) {
        if(this.name.compareTo(o.getName()) == 0) {
            return this.age - o.getAge() ;
        }
        return this.name.compareTo(o.getName());
    }
}
```

```java
package com.mantou.set;

import com.mantou.entity.Person;

import java.util.Comparator;
import java.util.TreeSet;

/**
 * @author mantou
 * @date 2021/11/4 15:52
 * @desc TreeSet特点
 *
 */
public class TreeSetTest {
    public static void main(String[] args) {
        //使用内部比较器
        TreeSet<Person> treeSet = new TreeSet<>();
        treeSet.add(new Person("mantou",23));
        treeSet.add(new Person("lisi",24));
        treeSet.add(new Person("mantou",25));
        treeSet.add(new Person("zhangsan",26));
        treeSet.add(new Person("wangwu",23));
        for (Person person : treeSet) {
            System.out.println(person);
        }
        System.out.println("------------------------------------------");
        //使用外部比较器，写法为直接传入匿名内部类
        TreeSet<Person> treeSet2 = new TreeSet<>(new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                if (o1.getName().compareTo(o2.getName()) == 0) {
                    return o1.getAge() - o2.getAge() ;
                }
                return o1.getName().compareTo(o2.getName());
            }
        });
        treeSet2.add(new Person("mantou2",23));
        treeSet2.add(new Person("lisi2",24));
        treeSet2.add(new Person("mantou2",25));
        treeSet2.add(new Person("zhangsan2",26));
        treeSet2.add(new Person("wangwu2",23));
        for (Person person : treeSet2) {
            System.out.println(person);
        }
    }
}
```

## 七丶比较器的使用

### 1.内部比较器

```java
package com.mantou.entity;

public class Student implements Comparable<Student>{

    private String name ;
    private Integer age ;

    public Student() {
    }

    public Student(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    //内部比较器
    @Override
    public int compareTo(Student o) {
        if(this.name.compareTo(o.name) == 0) {
            return this.age - o.age ;
        }
        return this.name.compareTo(o.name);
    }
}
```

### 2.外部比较器

```java
package com.mantou.compare;

import com.mantou.entity.Student;

import java.util.Comparator;
/**
 * @author mantou
 * @date 2021/11/4 14:56
 * @desc 外部比较器
 */
public class StudentCompare implements Comparator<Student> {

    @Override
    public int compare(Student o1, Student o2) {
        if (o1.getName().compareTo(o2.getName()) == 0) {
            return o1.getAge() - o2.getAge() ;
        }
        return o1.getName().compareTo(o2.getName()) ;
    }
}
```

### 3.比较器测试类

```java
package com.mantou.compare;

import com.mantou.entity.Student;
import java.util.Arrays;
import java.util.Comparator;

/**
 * @author mantou
 * @date 2021/11/4 14:41
 * @desc 比较器的使用
 * 外部比较器可以使用多态，所以扩展性更好
 */
public class CompareTest {
    public static void main(String[] args) {
        //使用内部比较器比较自定义对象
        Student stu1 = new Student("wangwu",23);
        Student stu2 = new Student("mantou",24);
        Student stu3 = new Student("mantou",25);
        Student stu4 = new Student("mantou", 23);
        Student[] students = new Student[] {stu1,stu2,stu3,stu4} ;
        Arrays.sort(students);
        for (Student student : students) {
            System.out.println(student);
        }
        System.out.println("-------------------------------------------");
        //使用外部比较器比较自定义对象
        Comparator<Student> comparator = new StudentCompare();
        Student[] students2 = new Student[] {stu1,stu2,stu3,stu4} ;
        Arrays.sort(students2 , new StudentCompare());
        for (Student student : students2) {
            System.out.println(student);
        }

    }
}
```

## 八丶Map接口

### 1.Map集合常用API

```java
package com.mantou.map;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * @author mantou
 * @date 2021/11/4 16:49
 * @desc Map集合常用方法
 * Map集合的特点：无序，唯一，key唯一  value不唯一
 *
 */
public class MapTest {
    public static void main(String[] args) {
        Map<String,Integer> map = new HashMap<>();
        //添加 put(K key, V value)
        map.put("mantou",111);
        map.put("zhangsan",222);
        map.put("lisi",333);
        map.put("wangwu",444);
        map.put("zhaoliu",555);
        System.out.println(map);
        //查找 entrySet() get(Object key) size() keySet()   values()
        System.out.println(map.get("mantou"));
        System.out.println(map.size());
        //遍历集合的所有key
        Set<String> strings = map.keySet();
        for (String string : strings) {
            System.out.println(string);
        }
        //遍历集合的所有值
        Collection<Integer> values = map.values();
        for (Integer value : values) {
            System.out.println(value);
        }
        //遍历集合的所有键值对
        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        for (Map.Entry<String, Integer> entry : entries) {
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }


        Map<String,Integer> map2 = new HashMap<>();
        //添加 put(K key, V value)
        map2.put("mantou",111);
        map2.put("zhangsan",222);
        map2.put("lisi",333);
        map2.put("wangwu",444);
        map2.put("zhaoliu",555);

        //判断 containsKey(Object key) containsValue(Object value) equals(Object o) isEmpty()
        System.out.println(map == map2);
        System.out.println(map.equals(map2));
        System.out.println(map.containsKey("mantou"));
        System.out.println(map.containsValue(222));
        //删除  clear() remove(Object key)
        map.clear();
        System.out.println(map);
        map2.remove("mantou");
        System.out.println(map2);
    }
}
```

### 2.HashTable集合

特点：API与HashMap相同，但是线程安全，效率低，key不可以为null，而HashMap的key值可以为null，并且唯一

### 3.LinkedHashMap集合

特点：唯一，有序（按照输入顺序输出），底层哈希表+链表

### 4.TreeMap集合

